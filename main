import numpy as np
import matplotlib.pyplot as plt
import cupy as cp # if no nvidia gpu change this to: 'import numpy as cp' without '
import matplotlib.animation as animation
import matplotlib.cm as cm
from numba import jit

def exp_gpu(z,c,iterations):
    for _ in range(iterations):
        z = cp.exp(z)+c
    return cp.isfinite(z)

def mandel_gpu(q,c,iterations):
    m = c
    for _ in range(iterations):
        m = cp.power(m,2)+c
        q[np.abs(m)<=2] += 1
    return cp.log(q+1)

res = 2000 # change according to your gpu-mem
frames = []
#set start
r = 0.25 
theta = cp.double(1.2)

x = r*cp.cos(theta)-1
y = r*cp.sin(theta)
num = np.double(4) # set starting range
#set zoom fac
zoom_fac = 0.95
# change this if images wiggly
correction_aggression = 0.12 
# change this to determine the divergence level for iterative zoom corrector (the lower the value, the higher the level of divergence)
divergence = 3


for i in np.arange(1,9901):
    iterations = 700
    z0 = cp.zeros((res,res),dtype=float)
    o, t = cp.meshgrid(cp.linspace(-num,num,res).astype(cp.cdouble)+x,cp.linspace(-num,num,res).astype(cp.cdouble)*1j+y*1j) # change offset here for poi
    dat = o + t
    z = mandel_gpu(z0,dat,iterations)
    anum = num/res
    # iterative zoom corrector
    unique = cp.unique(z).astype(cp.double)
    coord = cp.where(z.T == unique[int(unique.size/divergence)])
    coord = cp.vstack((coord[0],coord[1]))*2*anum
    new_coord = cp.argmin(cp.linalg.norm(coord - num,axis=0))
    new_coord = (coord[:,new_coord] - num)
    x += new_coord[0]*num*correction_aggression
    y += new_coord[1]*num*correction_aggression
    num *= zoom_fac
    # build image
    dpi = 80
    height, width = z.shape
    figsize = width / float(dpi), height / float(dpi)
    fig = plt.figure(figsize=figsize,frameon=False)
    ax = fig.add_axes([0, 0, 1, 1])
    ax.axis('off')
    ax.imshow(z.get())
    fig.savefig(f'./img/file{str(i).zfill(4)}.png',dpi=dpi)
    if i%99==0: print(i//90)
    plt.close(fig)
